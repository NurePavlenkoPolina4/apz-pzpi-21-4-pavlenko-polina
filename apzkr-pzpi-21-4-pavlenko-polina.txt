Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для організації та керування домашньою бібліотекою

Студентка гр. ПЗПІ-21-4                 _______________________ Павленко П.О.  
(підпис)

Керівник роботи                            ___________________ доц.Лещинська І.О.
(підпис)
Роботу захищено «__»_________2024 р.
з оцінкою _________________________

    Комісія:                                     ___________________ доц. Лещинський В.О.
(підпис)
_____________________ доц. Лещинська І.О.
(підпис)
___________________ ст.викл. Сокорчук І.П.
(підпис)


Харків
2024 р.
Аркуш Завдання

Харківський національний університет радіоелектроніки  

Факультет комп’ютерних наук            Кафедра програмної інженерії                 
Спеціальність 121 – Інженерія програмного забезпечення                                   
Курс             3           Семестр                                          6                                        
Навчальна дисципліна Архітектура програмного забезпечення                          

ЗАВДАННЯ 
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ
                                     Павленко Поліні Олексіївні                                               
1. Тема проєкту: Програмна система для організації та керування домашньою бібліотекою                                                                                          
2. Термін узгодження курсової роботи  « 27 »    березня  2024 р. 
3. Термін здачі студентом закінченої роботи  «  8  »     червня              2024 р.  
4. Вихідні дані до проєкту: Програмна система має реалізовувати використання програмного забезпечення та IoT-сенсорів для менеджменту та керування книгами з домашньої бібліотеки. Система має забезпечувати безпеку даних, включати інструменти адміністрування та бути орієнтована на масового користувача. 
5. Зміст пояснювальної записки (перелік питань, що належить розробити)
вступ, аналіз предметної області, постановка задачі, проектування програмного проекту, структура бази даних, кодування програмного проекту, опис розробленої програмної системи, висновки, перелік посилань, додатки 
6. Перелік графічного матеріалу (діаграми, рисунки, інтерфейси)  схема бази даних, діаграма варіантів використання, діаграма розгортання, інтерфейс головної сторінки                                                                                              

КАЛЕНДАРНИЙ ПЛАН


№Назва етапу курсової роботиТермін виконанняПримітка1Функціональна специфікація
програмного проєкту26.02.2024 - 27.03.2024 р.виконано2Проектування програмного
проєкту30.03.2024 - 05.04.2024 р.виконано3Кодування програмного проєкту05.04.2024 - 29.05.2024 р.виконано4Оформлення пояснювальної
записки30.05.2022 - 05.06.2024 р.виконано5Захист курсової роботи06.06.2024 - 08.06.2024 р.

Дата видачі теми проєкту «   27   »         березня         2024 р.  

Керівник                                                                    доц.Лещинська І.О.
  					  	(підпис)  

Завдання прийняла до виконання 
     ст.гр. ПЗПІ-21-4                                                         Павленко П.О.    
  					  	    (підпис)  



РЕФЕРАТ
     
     
     Пояснювальна записка до курсової роботи: с. 66, рис. 20, табл. 3, додатки 3, джерел 7.
     ДОМАШНЯ БІБЛІОТЕКА, КНИГА, ОРГАНІЗАЦІЯ, ВПОРЯДКУВАННЯ, НОТАТКИ, РЕЙТИНГ, CИСТЕМА УПРАВЛІННЯ.
     Об'єктом дослідження виступають домашні бібліотеки, тобто колекції книг, які зберігаються в домашніх умовах. Розглядаються сучасні проблеми, пов'язані з організацією та систематизацією книжкових полиць. 
     Метою курсової роботи є розробка системи, що забезпечує підвищення ефективності управління персональними бібліотеками користувачів, а саме зберігає дані про додані книги, надає можливість сортування та впорядкування збережених даних, впроваджує можливість пошуку книг, забезпечує можливість надання кожній книзі рейтингів та нотаток.
     Метою даної курсової роботи є розробка комплексної системи, що підвищує ефективність управління персональними бібліотеками користувачів. Система забезпечує збереження даних про всі додані книги. Система надає можливість додавання нових книжок, сортування та впорядкування збережених даних, надає функціонал пошуку книг та забезпечує можливість надання кожній книзі рейтингів та нотаток.
     Методи розробки серверної частини базуються на мові програмування Node.js та фреймворку Express, MongoDB використовується в якості бази даних, клієнтська частина базується на використанні бібліотеки React, систему для забезпечення розширеної функціональності для зчитування штрих-кодів книжок, що відповідає концепції смарт пристрою, розроблено на мові програмування C#.
     У результаті роботи здійснено програмну реалізацію системи організації та керування домашньою бібліотекою. Програмна система складається з веб-додатку, сервера та смарт пристрою.
ЗМІСТ


Вступ	6
1 Аналіз та концептуальне моделювання предметної області	7
1.1	Бізнес-вимоги	7
1.1.1	Бізнес можливості	7
1.1.2	Бізнес-цілі та критерії успіху	8
1.1.3	Потреби клієнтів або ринку	9
1.1.4	Бізнес-ризики	10
1.2	Концепція рішення	12
1.2.1	Окреслення концепції	12
1.2.2	Головна функціональність	13
1.2.3	Припущення та залежності	14
1.3	Рамки та обмеження проєкту	16
1.3.1	Рамки первинного випуску	16
1.3.2	Рамки наступних випусків	17
1.3.3	Обмеження та винятки	18
1.4	Бізнес-контекст	19
1.4.1	Профілі зацікавлених сторін	19
1.4.2	Пріоритети проєкту	20
1.4.3	Робоче середовище	21
2 Постановка задачі	22
3 Проектування програмного проєкту	24
3.1	Проектування серверної частини проєкту	24
3.2	Проектування IoT частини проєкту	28
3.3	Проектування клієнтської частини проєкту	33
4 Кодування програмного проєкту	37
4.1	Кодування серверної частини проєкту	37
4.2	Кодування IoT частини проєкту	40
4.3	Кодування клієнтської частини проєкту	42
Висновки	49
Перелік джерел посилання	50
Додаток А	51
Додаток Б	57
Додаток В	61
Додаток Г	66

     


ВСТУП
     
     
     З розвитком технологій змінилися способи управління особистими бібліотеками. Традиційні методи організації книг у домашніх бібліотеках часто неефективні та незручні, що призводить до розчарування та безладу. Люди можуть не помічати, що вже мають певну книгу у своїй колекції, що на перший погляд здається незначною проблемою, проте може призводити до непотрібного дублювання видань та перевантаження полиць.
     Без належного сортування книги можуть бути розкидані по всій квартирі, що ускладнює їх пошук і підтримку порядку. Відсутність можливості легко перевірити наявність книги перед покупкою також важлива, оскільки це може призводити до марнування часу, грошей та простору, які могли б бути використані для придбання нових книг або для інших цілей.
     Ці проблеми підкреслюють актуальність розробленої програмної системи для організації та керування домашньою бібліотекою. Завдяки розвитку програмного забезпечення та інтернету речей, замість хаосу неорганізованих книжкових полиць і сумнівів щодо наявності певних книг, користувачі можуть мати всю цю інформацію в одному зручному місці.
     Система дозволяє легко додавати книги в застосунок за допомогою введення ISBN-номера або сканування штрих-коду. Зберігаючи всі книги в додатку, користувач отримує швидкий та зручний доступ до детальної інформації про кожну книгу, можливість оцінювати книги, залишати коментарі та впорядковувати дані за різними критеріями. Застосунок є простим для розуміння і використання, що дозволяє людині з будь-яким рівнем досвіду швидко його освоїти.
     


1 АНАЛІЗ ТА КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРЕДМЕТНОЇ ОБЛАСТІ
     1.1 Бізнес-вимоги
     1.1.1 Бізнес можливості
     
     
     Ринкові можливості для пропонованої програмної системи для організації та управління домашніми бібліотеками є значними, що зумовлено зростаючою цифорвізацією особистих активів та зростаючим бажанням спростити управління повсякденними завданнями. В даний час люди, які підтримують особисті книжкові колекції, стикаються з проблемами в ефективній організації, відстеженні та доступі до своїх книг.
     Goodreads [1], як відома платформа для любителів книг, представляє значний конкурентний виклик у розглянутому сегменті ринку. Однією з головних переваг Goodreads є широкий функціонал, що включає можливість створення та оцінювання списків книг, обговорення та рецензування книг, спілкування з іншими читачами, а також отримання персоналізованих рекомендацій щодо нових книг на основі історії читання користувача. Платформа також дозволяє користувачам створювати та приєднуватися до книжкових груп і дискусій, отримувати рекомендації на основі попередніх прочитаних книг та взаємодіяти з іншими читачами. Однак, не зважаючи на успіх Goodreads, платформа не є панацеєю і має певні недоліки. Goodreads був запущений на ринок понад десять років тому і протягом цього часу майже не отримав значних оновлень. Це призвело до того, що платформа залишається заздалегідь відсталим у порівнянні з сучасними технологічними стандартами. Це створює благоприятну умову для введення на ринок більш сучасної та зручної альтернативи.
     На відміну від Goodreads, описуваний продукт в першу чергу акцентує увагу на внутрішній організації бібліотеки, спрощуючи процеси каталогізації та управління книжковою колекцією. Він пропонує зручний інтерфейс для сканування книжкових штрих-кодів, що дозволить користувачам швидко додавати книги до цифорвої бібліотеки без необхідності ручного введення даних.
     Хоча як  програмна система для організації та керування домашньою бібліотекою не прагне включати таку розмаїтість функціоналу, як Goodreads, вона зосереджена на якості та ефективності запропонованих можливостей. Більшість сучасних користувачів охоче приймуть нові рішення, якщо вони пропонуватимуть значні переваги у порівнянні з вже існуючими продуктами. Отже, поява більш сучасного та функціонального продукту, такого як  програмна система для організації та керування домашньою бібліотекою, має великий потенціал у сучасну цифрову епоху.
     
     
     1.1.2 Бізнес-цілі та критерії успіху
     
     
     Основні бізнес-цілі запропонованого продукту полягають у підвищенні ефективності управління персональною бібліотекою, збільшенні залученості користувачів та захопленні значної частки цільового ринку. Для досягнення цих цілей було встановлено наступні вимірювані критерії успіху:
     BO-1: Задовольнити зростаючий попит на ефективні рішення для управління особистими книжковими колекціями в цифрову епоху.
     BO-2: Запропонувати спрощену альтернативу існуючим рішенням зосередившись на простоті та ефективності.
     BO-3: Використання технологій інтернету речей для спрощення процесу каталогізації та управління книжками.
     BO-4: Отримання доходу за рахунок преміум-планів підписки та рекламних партнерств.
     BO-5: Формування міцної репутації бренду як лідера в галузі програмного забезпечення для організації книжкових колекцій.
     BO-6: Покращення користувацького досвіду та задоволеності завдяки інтуїтивно зрозумілому дизайну та постійному вдосконаленню.
     Критерії успіху:
     SC-1: Збільшення кількості користувачів на 20% протягом першого року з моменту запуску продукту.
     SC-2: Досягнення показника утримання користувачів на рівні не менше 70% протягом перших двох років після впровадження продукту.
     SC-3: Дохід від преміум-планів підписки в розмірі не менше $100 000 протягом першого року.
     SC-4: Досягнення 15% зростання доходу протягом перших двох років.
     SC-5: Мінімізація витрат на підтримку клієнтів шляхом створення інтуїтивно зрозумілої та зручної платформи, що призведе до скорочення кількості звернень до служби підтримки на 20% протягом першого року.
     SC-6: Захоплення щонайменше 10% частки ринку в сегменті програмного забезпечення для організації домашніх бібліотек протягом перших двох років.
     
     
     1.1.3 Потреби клієнтів або ринку
     
     
     З розповсюдженням цифрових медіа та зростанням популярності електронних книг і аудіокниг, люди накопичують більші та різноманітніші колекції книг, ніж будь-коли раніше. Однак традиційні методи організації та каталогізації цих колекцій часто забирають багато часу та є неефективними, що призводить до розчарування та дезорганізації.
     Клієнти в цьому сегменті ринку мають різноманітні потреби та вподобання, коли йдеться про управління домашніми бібліотеками. Вони шукають рішення, які спрощують процес поповнення своїх колекцій новими книжками, незалежно від того, чи придбані вони онлайн, чи позичені у друзів, чи отримані в інший спосіб. 
     Доступність і зручність також є важливими факторами для користувачів, які очікують мати доступ до своїх бібліотек з будь-якого пристрою і в будь-який час. Для цього потрібні рішення, сумісні з різними апаратними і програмними середовищами, включаючи стаціонарні комп'ютери, ноутбуки, планшети і смартфони. Зручний інтерфейс має важливе значення для забезпечення безперебійної та інтуїтивно зрозумілої роботи користувача, мінімізуючи потребу в навчанні або технічній підтримці.
     Зрештою, клієнти шукають економічно ефективні рішення, які забезпечують хороше співвідношення ціни та якості. Вони хочуть мати прозору структуру ціноутворення, гнучкі варіанти оплати, а також постійну підтримку та оновлення для забезпечення безперервної функціональності та актуальності продукту.
     Задовольняючи ці потреби ринку і клієнтів, запропонований  продукт прагне зайняти свою нішу на конкурентному ринку програмного забезпечення для організації домашніх бібліотек, пропонуючи комплексне і зручне рішення, яке відповідає зростаючим потребам сучасних читачів.
     
     
     1.1.4 Бізнес-ризики
     
     
     До основних ризиків відносяться:
      а) Конкуренція на ринку. Одним з основних ризиків, пов'язаних з розробкою цього продукту, є наявність сильної конкуренції на ринку. Такі відомі гравці, як Goodreads та інші програмні рішення для організації домашніх бібліотек, вже мають значну частку ринку та базу лояльних клієнтів. Ризик бути затьмареним цими конкурентами є високим, особливо якщо запропонований продукт не зможе виділитися або запропонувати унікальні ціннісні пропозиції. Ступінь серйозності – високий. Щоб зменшити цей ризик, буде проведено ретельний аналіз пропозицій конкурентів для виявлення прогалин на ринку, які може заповнити даний продукт. Увагу буде зосереджено на підкресленні унікальних особливостей та переваг продукту за допомогою цілеспрямованих маркетингових та брендингових зусиль.
      б) Технічні виклики. Існує ризик зіткнутися з технічними перешкодами під час розробки, такими як проблеми сумісності з різними пристроями або операційними системами, або труднощі з реалізацією складних функцій, таких як точне сканування штрих-кодів у різних книжкових виданнях. Ступінь серйозності – високий. Для виявлення та вирішення технічних проблем на ранній стадії розробки буде проведено ретельне тестування та створення прототипів
      в) Прийняття користувачами. Незважаючи на очевидну потребу в продукті, існує ризик, що користувачі можуть не прийняти його так, як очікувалося, через такі фактори, як опір змінам, недостатня обізнаність або надання переваги існуючим рішенням. Ступінь серйозності – середній. Для підвищення обізнаності та зацікавленості в продукті будуть проводитися цілеспрямовані маркетингові кампанії та кампанії з навчання користувачів. Крім того, включення зворотного зв'язку з користувачами в процес розробки та постійне вдосконалення продукту на основі потреб та вподобань користувачів підвищить потенціал його впровадження.
      г) Залежність від сторонніх сервісів: Залежність від сторонніх сервісів для критично важливих функцій, таких як сканування штрих-кодів або хмарне зберігання даних, створює ризик перебоїв у наданні послуг, зміни умов надання послуг або залежність від життєздатності зовнішніх постачальників. Ступінь серйозності – середній. За можливістю слід диверсифікувати залежності, вивчити варіанти резервного копіювання та розробити плани на випадок непередбачуваних ситуацій, щоб пом'якшити перебої, спричинені проблемами з послугами сторонніх постачальників. Крім того, підтримання відкритої комунікації та моніторинг роботи сторонніх провайдерів допоможе ефективно зменшити ризик.
     
     
     1.2 Концепція рішення
     1.2.1 Окреслення концепції
     
     
     Концепція проєкту Shelfy – дати людям можливість без зайвих зусиль організовувати та керувати власними книжковими колекціями, розширюючи їхні читацькі можливості та вдосконалюючи їхнє життя. Із запропонованим продуктом користувачі більше не будуть боротися з проблемами ручної каталогізації книг або розчаруванням від дублюючих покупок. Замість цього вони зможуть насолоджуватися зручністю ведення електронного обліку за допомогою технології сканування штрих-кодів, що дозволить їм швидко створювати і легко впорядковувати свої колекції.
     Програмна система для організації та керування домашньою бібліотекою складатиметься з серверної частини, веб та мобільного додатку та інструменту, що допоможе зчитувати інформацію зі штрих-коду. Серверний компонент є основою нашої системи, що відповідає за управління зберіганням даних, автентифікацію користувачів та полегшення комунікації між клієнтами. Він використовуватиме надійні системи управління базами даних для безпечного зберігання профілів користувачів, інформації про книги та створеного користувачами контенту, такого як оцінки та нотатки. Веб-додаток слугуватиме основним інтерфейсом для користувачів для доступу та управління особистими бібліотеками зі стаціонарних комп'ютерів та ноутбуків. Він матиме інтуїтивно зрозумілий і зручний інтерфейс, що дозволить користувачам переглядати свої книжкові колекції та додавати нові книги за допомогою сканування штрих-коду або ручного введення. Крім того, веб-додаток буде адаптивним, що забезпечить безперебійну роботу користувачів на різних розмірах екранів і в різних веб-браузерах. Мобільний додатки, доступний для платформи Android, розширить функціональність системи на смартфони та планшети користувачів. Інструмент зчитування штрих-кодів буде інтегрований як у веб, так і в мобільні додатки, що дозволить користувачам швидко і точно додавати книги до своїх електронних бібліотек, скануючи штрих-код на задній обкладинці книги.
     Разом ці компоненти сформують комплексну та згуртовану екосистему, яка дозволить користувачам ефективно організовувати та керувати своїми особистими бібліотеками, незалежно від того, якому пристрою чи платформі вони надають перевагу.
     
     
     1.2.2 Головна функціональність
     
     
     Головна функціональність системи спрямована на ефективне управління основними аспектами менеджменту домашньої бібліотеки. Вона включає в себе наступні ключові можливості:
     MF-1: Реєстрація та автентифікація користувачів. Система має надавати можливість користувачам створювати особисті облікові записи, реєструючись через електронну пошту.
     MF-2: Додавання та видалення книг. Користувачі мають можливість додавати нові книги до своєї колекції шляхом сканування штрих-кодів або  введенням ISBN коду книги вручну. Також існує можливість видалення книг з бібліотеки за необхідності.
     MF-3: Сортування. Система має дозволяти користувачам відсортовувати книги за різними критеріями, такими як жанр, автор, рік видання, рейтинг, тощо.
     MF-4: Персоналізовані рейтинги та відгуки. Користувачі мають можливість надавати книгам персональні рейтинги та залишати нотатки, що надаватиме їм можливість відстежувати свої уподобання та рекомендації.
     MF-5 Зручний пошук. Система  має забезпечувати швидкий і зручний пошук книг за назвою, автором або іншими ключовими словами. Це допомагатиме користувачам легко знаходити потрібні книги у своїй колекції.
     MF-6: Веб доступ. Користувачі мають можливість отримати доступ до своєї бібліотеки через веб-інтерфейс з будь-якого пристрою з доступом в Інтернет. Веб-додаток дозволяє керувати книгами та переглядати колекцію на будь-якому пристрої з веб-браузером.
     MF-7: Мобільний доступ. Користувачі можуть отримати доступ до своєї бібліотеки з будь-якого мобільного Android пристрою за допомогою спеціального мобільного додатку. Мобільний доступ дозволяє користувачам керувати своєю колекцією навіть у дорозі або поза дому.
     MF-8: Зчитування штрих-кодів: Користувачі можуть використовувати функціональність зчитування штрих-кодів, щоб швидко та зручно додавати нові книги до своєї бібліотеки. За допомогою спеціального IoT пристрою користувачі можуть сканувати штрих-коди з обкладинок книг і автоматичного додавати їх до колекції у застосунку.
     
     
     1.2.3 Припущення та залежності
     
     
     Припущення:
     а) Передбачається, що користувачі шукають зручну платформу, яка спрощує процес каталогізації та відстеження їхніх книжкових колекцій, заощаджуючи час і зусилля.
     б) Припускається, що користувачі матимуть доступ до смартфонів або комп'ютерів з підключенням до Інтернету, щоб ефективно використовувати веб та мобільні додатки.
     в) Припускається, що користувачі матимуть базові навички грамотності для навігації та взаємодії з інтерфейсами додатків.
     г) Припускається, що користувачі надаватимуть точну інформацію під час додавання книг до своєї бібліотеки, вводячи її вручну або скануючи штрих-код.
     д) Передбачається, що функція сканування штрих-коду буде ефективно працювати в широкому діапазоні обкладинок і станів книг, забезпечуючи точне вилучення даних.
     Залежності:
     а) Успіх проєкту залежить від доступності та надійності технології сканування штрих-кодів, що може передбачати залежність від сторонніх бібліотек або API для точного вилучення даних.
     б) Проєкт залежить від безпечної та стабільної серверної інфраструктури для безпечного зберігання та управління даними користувачів.
     в) Ресурси та компетентність розробки є залежністю для реалізації веб та мобільних додатків, включаючи клієнтську та серверну частини розробки.
     г) Успіх проєкту може також залежати від прийняття та залучення користувачів, що вимагає ефективного маркетингу та зусиль з розбудови спільноти.
     
     
     
     
     
     
     1.3 Рамки та обмеження проєкту
     1.3.1 Рамки первинного випуску
     
     
     Початковий випуск продукту фокусуватиметься на забезпеченні основних функцій, спрямованих на надання користувачам безперешкодного та ефективного досвіду в управлінні їхніми особистими книжковими колекціями. Основні функції,  включені в початкову версію, є наступними:
     SIR-1: Реєстрація та авторизація користувачів.
     SIR-2: Додавання та каталогізація книг за допомогою пристрою для сканування штрих-кодую. 
     SIR-3: Додавання та каталогізація книг за допомогою використання ISBN коду книги.
     SIR-4: Перегляд інформації про книгу.
     SIR-5: Функціонал пошуку за такими параметрами як: назва, автор, ISBN.
     SIR-6: Присвоювання рейтингу книгам.
     SIR-7: Написання приміток до книг.
     SIR-8: Сортування книг за такими критеріями як: назва, автор, рейтинг, дата додавання до колекції.
     SIR-9: Перегляд користувацького профілю.
     SIR-10: Редагування користувацької інформації та зміна паролю.
     SIR-11: Вихід користувача з системи.
     SIR-12: Управління користувачами. Доступно тільки адміністратору системи.
     SIR-13: Функції резервного копіювання та відновлення.
     SIR-14: Веб- та мобільний доступ.
     SIR-15: Підтримка української та англійської мов.
     SIR-16: Перегляд та обробка статистики щодо книжкових вподобань користувачів. Доступно тільки адміністратору системи.
     1.3.2 Рамки наступних випусків
     
     
     Наступний реліз буде зосереджений на вдосконаленні існуючих функцій та впровадженні кількох ключових покращень для підвищення рівня задоволеності та залученості користувачів. Розширені функції, які планується реалізувати:
     SSR-1: Механізм персоналізованих рекомендацій. Розробка механізму рекомендацій, який використовуватиме алгоритми машинного навчання для аналізу вподобань користувачів, їхніх читацьких звичок та оцінок. Надання персоналізованих книжкових рекомендацій на основі індивідуальних профілів користувачів, що сприятиме відкриттю нових назв та авторів.
     SSR-2: Динамічна систематизація. Удосконалена система організації дозволить користувачам динамічно класифікувати свої книги на основі широкого спектру характеристик, таких як жанр, автор, рік видання, мова тощо. Користувачі матимуть змогу створювати та присвоювати декілька категорій кожній книзі, що полегшить їхню організацію та пошук.
     SSR-3: Покращена підтримка багатомовності та інтернаціоналізації. Ця функція задовольнить різноманітну базу користувачів, пропонуючи багатомовну підтримку та варіанти локалізації, гарантуючи, що користувачі з усього світу зможуть взаємодіяти з продуктом на своїй мові та в своєму культурному контексті.
     SSR-4: Інтеграція з соціальними мережами. Користувачі матимуть можливість легко ділитися своїм читацьким прогресом, улюбленими книгами та рецензіями на популярних платформах соціальних мереж, сприяючи залученню спільноти та полегшуючи дискусії серед книголюбів.
     SSR-5: Створення групових колекцій: Користувачі зможуть створювати групові колекції та запрошувати до них друзів.  У груповій колекції буде спільний книжковий каталог, куди учасники можуть додавати книги зі своїх особистих бібліотек або шукати нові видання для включення в колекцію.
     1.3.3 Обмеження та винятки
     
     
     Хоча новий продукт має на меті надати комплексне рішення для управління особистими книжковими колекціями та сприяння залученню громадськості, є певні функції та характеристики, які зацікавлені сторони можуть очікувати, але які не планується включати в початкову версію:
     LE-1: Читання в додатку. Продукт не підтримуватиме читання книг у додатку. Хоча користувачі можуть каталогізувати свої книги, платформа не надаватиме функціональності для читання електронних книг або доступу до цифрового контенту безпосередньо в додатку.
     LE-2: Форуми та обговорення. Початковий реліз не включатиме спеціальних форумів чи дискусійних дошок у додатку. Платформа не буде пропонувати окремі форуми чи дискусійні функції для ширшої взаємодії спільноти.
     LE-3: Інтеграція з бібліотеками. Початкова версія буде зосереджена на управлінні домашніми книжковими колекціями користувачів. Інтеграція з бібліотеками або бібліотечними системами для ширшого використання не планується в початковій версії продукту.
     Ці обмеження та виключення ґрунтуються на пріоритетності основних функцій, обмеженнях розвитку та стратегічних міркуваннях. Хоча ці функції можуть бути розглянуті для майбутніх випусків на основі відгуків користувачів і ринкового попиту, вони не є частиною початкової версії продукту.
     
     
     
     
     
     
1.4 Бізнес-контекст
1.4.1 Профілі зацікавлених сторін

     Таблиця 1 – Профілі зацікавлених сторін
Зацікавлена ??сторонаГоловна цінністьСтавленняГоловний інтересОбмеженняІндивідуальні користувачі (книголюби)Покращення організації та управління особистими книжковими колекціямиВисока сприйнятливість до продукту, зацікавлені у продукті, що покращить досвід організації книжокПростий у використанні інтерфейс для каталогізації та управління особистими книжковими колекціямиОбмежений бюджет на придбання IoT пристроїв, додаткові платні функції або преміум-сервісиВидавництва та автори Доступ до статистики та інформації про користувачів додатку та їхні книжкові вподобанняВисока зацікавленість у використанні даних з додатку для маркетингових досліджень та рекламної діяльностіДоступ до інструментів аналітики та звітності для відстеження популярності книг, залучення читачів та показників продажівПотреба у прозорих практиках обробки даних та дотриманні правил конфіденційностіВласник проєктуДосягнення цілей проєкту та успішний реліз продукту в рамках визначених строківВисока зацікавленість в успіху проєкту, прагнення до максимізації прибутку на вкладений капітал та створення цінностіРегулярні оновлення та звіти про стан справ для моніторингу прогресу та реалізації проєктуПотреба у дотриманні бюджетних та часових обмежень проєктуРозробникиМожливість працювати над інноваційними та складними проєктами, які сприяють професійному зростанню та розвиткуВисока мотивація сприяти успіху продукту через творче вирішення проблем та технічну експертизуДоступ до ресурсів та інструментів, які сприяють ефективній та результативній розробці програмного забезпеченняНеобхідність чіткої комунікації та документування вимог та очікувань проєкту     
     
     1.4.2 Пріоритети проєкту

     Таблиця 2 – Пріоритети проєкту
ПоказникВиконання
(етапи)Обмеження
(Граничні значення)Ступінь свободи
(Допустимий діапазон)План робітВипуск 1.0 має відбутись до 01.06.2024Розробка серверної частини має відбутись до 19.04.2024
Розробка програмного забезпечення для IoT до 30.04.2024
Розробка клієнтської частини до 15.05.2024
Розробка мобільного додатку до 29.05.2024Весь запланований функціонал має бути впроваджено до зазначеної дати релізу версії 1.0, додаткове тестування може бути проведено після релізу на основі  часових обмежень і доступності ресурсів ФункціональністьВипуск версії 1.0 має включати розробку всіх ключових функцій, що характеризують проєкт Всі головні функції, визначені в рамках проєкту, повинні бути включені до версії 1.070-80% високо пріоритетних функцій має бути впроваджено у  версії 1.0ЯкістьВиділення достатнього часу та ресурсів для ретельного тестування та забезпечення якостіУспішне проходження користувальницьких тестів до релізу версії 1.090-95% користувальницьких тестів повинні бути пройдені для версії 1.0, 95-98% для версії 1.1ПерсоналРізноманітність навичок та досвідТільки один розробник.Над виконанням проєкту має працювати тільки одна особаЦінаЕфективний розподіл ресурсів та стратегії управління витратами для мінімізації витрат при досягненні цілей проєктуДотримання бюджетуПеревитрата бюджету до 15% є прийнятною     
     
     1.4.3 Робоче середовище
     
     
     Серверна частина системи буде побудована з використанням Node.js та Express, що забезпечить надійний фреймворк для обробки HTTP-запитів та управління бізнес-логікою додатку. 
     MongoDB слугуватиме системою управління базами даних, пропонуючи масштабованість та гнучкість для ефективного зберігання та пошуку даних. Ця архітектура забезпечить безперебійний зв'язок між клієнтськими інтерфейсами та сервером, гарантуючи безперебійну роботу та швидкість доступу користувачів до системи.
     Клієнтська частина використовуватиме React, популярну бібліотеку JavaScript для побудови користувацьких інтерфейсів, для створення динамічного та інтерактивного досвіду. HTML та CSS використовуватимуться для структурування та стилізації веб-інтерфейсів, покращуючи зручність використання та візуальну привабливість. Завдяки використанню компонентної архітектури React, клієнтські інтерфейси будуть модульними та простими в підтримці, що полегшить ефективну розробку та оновлення.
     Для зчитування штрих-кодів система буде інтегрована з Arduino, використовуючи мову програмування C# у середовищі розробки  Visual Studio. Цей IoT-компонент дозволить користувачам сканувати штрих-коди книг, швидко додаючи книги у застосунок. Рішення на базі Arduino підвищить універсальність та зручність використання системи, забезпечуючи безшовну інтеграцію між фізичним та цифровим середовищами. 
     Крім того, буде розроблено мобільний додаток за допомогою Kotlin в Android Studio для користувачів, які віддають перевагу доступу до системи зі своїх смартфонів або планшетів. Мобільний додаток пропонуватиме функціональність, подібну до веб-інтерфейсів, дозволяючи користувачам керувати своїми книжковими колекціями. 
2 ПОСТАНОВКА ЗАДАЧІ
     
     
     Програмна система для організації та керування домашньою бібліотекою Shelfy повинна підтримувати наступний функціонал:
      * Реєстрація, вхід та вихід з системи. Забезпечення процесу створення облікового запису новими користувачами шляхом введення основної інформації (ім'я, електронна пошта, пароль). Можливість входу в систему для вже зареєстрованих користувачів з використанням електронної пошти та пароля. Забезпечення можливості користувачам безпечно виходити з системи.
      * Користувацький профіль. Надання користувачам можливості редагувати та переглядати свою особисту інформацію, таку як: ім’я, електронна пошта та пароль.
      * Додавання та каталогізація книг за допомогою пристрою для сканування штрих-кодів. Функціонал для додавання книг у систему шляхом сканування штрих-коду за допомогою спеціального консольного додатку.
      * Додавання книг у систему шляхом введення їх ISBN коду вручну. Автоматичне заповнення інформації про книгу (назва, автор, жанр) після додання книги на полицю.
      * Перегляд, редагування та видалення інформації про книгу. Надання детальної інформації про книгу, включаючи назву, автора, жанр, рік видання, опис та користувацькі примітки, такі як рейтинг, статус та коментарі. Можливість редагувати користувацькі примітки та видаляти книги з полиці.
      * Пошук і сортування. Можливість пошуку доданих користувачем книг за допомогою різних параметрів, таких як назва книги, ім'я автора чи ISBN код. Опції для сортування книг на полиці користувача за різними критеріями, такими як назва, автор, рейтинг та дата додання.
      * Адміністративний функціонал. Можливість перегляду даних користувачів, зміни ролей та видалення користувацьких профілів з системи.
      * Підтримка української та англійської мов. Можливість вибору мови інтерфейсу між українською та англійською у головній системі та системі адміністрування.



3 ПРОЕКТУВАННЯ ПРОГРАМНОГО ПРОЄКТУ
2 
3 
3.1 Проектування серверної частини проєкту

     
     Діаграма розгортання системи проєкту демонструє фізичну структуру та розташування компонентів системи на різних пристроях. Це важливий інструмент для аналізу та візуалізації взаємодії між компонентами та їх розподілу. Розроблену діаграму наведено на рисунку 1.
     Серверна частина застосунку побудована на базі Node.js та фреймворку  Express.js. Його головна функція - обробка HTTP-запитів та взаємодія з базою даних MongoDB [2] для зберігання та отримання даних. Також серверна частина застосунку взаємодіє з Google Books API [3] для отримання додаткової інформації про книги.  Сервер відповідає за бізнес-логіку додатку та забезпечення API, побудованого на базі архітектури REST, для взаємодії з клієнтським і мобільним додатком.
     База даних MongoDB використовується для зберігання структурованих даних системи, таких як інформація про користувачів, книги, та полиці. Вона розгорнута на віддаленому сервері баз даних MongoDB Atlas.
     IoT-пристрій, написаний на C++, відправляє зчитані зі штрих-кодів дані на сервер через HTTP-запити для подальшої обробки та аналізу.
     Клієнтський веб-додаток використовує бібліотеку React.js для побудови клієнтського інтерфейсу. Веб-додаток взаємодіє з сервером через REST API запити для отримання та відображення даних користувачам через веб-сайт.
     Мобільний додаток, розроблений на Kotlin, доступний на  мобільному пристрої з операційною системою Android. Він використовує REST API для отримання даних з сервера та взаємодії з системою.
     Ця діаграма розгортання допомагає зрозуміти, як фізично розташовані компоненти системи та як вони взаємодіють між собою через мережу для забезпечення функціональності та обслуговування потреб користувачів.

     Рисунок 1 – UML діаграма розгортання
     
     UML-діаграма прецедентів [5] є інструментом моделювання, який використовується для візуалізації функціональності системи з точки зору користувача. UML-діаграму прецедентів зображено на рисунку 2,  вона відображає різноманітні дії та взаємодію користувачів з системою.
     Головним актором у системі є «Користувач». «Користувач» має можливість реєстрації та подальшого входу у систему, що надає йому можливість керувати менеджментом книжкової полиці. «Користувач» має можливість переглядати останні книжкові доповнення, передивлятись всі збережені у системі книжки, шукати, сортувати та видаляти інформацію, передивлятись розширену інформацію до кожної доданої книги. «Користувач» також має можливість додавати нові книги у два способи: за допомогою IoT пристрою для зчитування штрих-кодів та ручного введення ISBN коду книги у веб або мобільному додатку. Інформацію про кожну збережену книгу «Користувач» може доповнювати такими даними як: рейтинг, статус та особисті нотатки.   
     Кожен «Користувач» має доступ до особистого кабінету де він може редагувати конфіденційні дані, такі як електрона пошта та пароль. 
     Зокрема актора «Користувач» у системі також присутні актори «Гість» та «Адміністратор». «Гість» має доступ лише до можливостей  реєстрації та входу у систему, а актор «Адміністратор» має доступ до всіх даних системи та має можливості редагування та видалення цієї інформації.

     Рисунок 2 – UML діаграма прецедентів
     
     ER-діаграма (сутність-зв'язок) є важливим інструментом при проектуванні баз даних. Вона надає можливість детально зрозуміти структуру даних та взаємозв'язки між різними об'єктами в системі.
     Розроблену діаграму наведено на рисунку 3.

     Рисунок 3 – ER діаграма
     
     ER діаграма складається з шести ключових компонентів, на базі яких було розроблено базу даних. 
     Ці компоненти включають у себе:
     а) Користувачі.  Цей компонент представляє користувачів системи, він містить основні атрибути, такі як ім'я, електронна пошта, роль (user/admin), які визначають користувачів. Користувачі використовують систему для додавання книг до своєї полиці, оцінки книг, перегляду списку книг тощо.
     б) Автентифікаційний токен. Цей компонент відповідає за токени автентифікації, які використовуються для авторизації користувачів у системі. 
     в) Пристрій. Цей компонент представляє пристрої, які використовуються для сканування штрих-кодів книг.
     г) Книжкова полиця. Цей компонент відповідає за зв’язок відповідних книжок із користувачами. Він містить дані про кількість книг доданих на полицю користувачем.
     д) Книги. Цей компонент містить інформацію про книги, які доступні в системі. Він містить основні атрибути книг, такі як ISBN, назва, автор, рік видання, жанр, опис.
     е) Рейтинг. Цей компонент відповідає за зберігання оцінки та нотатків та статусу користувача щодо відповідної книги.
     Варто зазначити, що завдяки гнучкості MongoDB, яка надає можливість зберігати зв’язані дані в одній колекції і використовувати вкладені об’єкти або масиви для представлення зв’язків між даними, такі сутності як рейтинг, книжкова полиця та автентифікаційний токен не були відтворені у окремі колекції.   
     
     
     3.2 Проектування IoT частини проєкту
     
     
     UML-діаграма прецедентів є потужним інструментом, що дозволяє не лише візуалізувати функціональність системи, але й зосередитися на взаємодії користувача з нею. UML-діаграму прецедентів для програмного забезпечення, що реалізовує функціональність,  яка відповідає концепції IoT пристрою зображено на рисунку 4. 

     Рисунок 4 – UML діаграма прецедентів
     
     Головним актором даної системи є «Користувач». Задля захищеного використання програмного забезпечення «Користувач» має спочатку увійти в систему. Для того щоб додати нову книгу на «віртуальну книжкову полицю», тобто зберегти її у додатку, «Користувач» має можливість зчитати ISBN ідентифікаційний номер книги, надавши фотографію, на якій зображено задню частину книжкової палітурки або іншого місця, де на книзі розташовано штрих-код. Якщо всі операції було проведено успішно, «Користувач» має можливість передивитись додані дані у додатку.
     UML діаграма взаємодії [5] використовується для моделювання та візуалізації взаємодії між об'єктами або компонентами в системі, щоб уявити послідовність повідомлень або дій, які передаються між ними у різних сценаріях взаємодії. Розроблену діаграму взаємодії наведено на рисунку 5, вона демонструє взаємодію користувача із програмним забезпеченням для додавання книги на «полицю».
     Взаємодія починається із входом користувача у систему. У разі, якщо введені дані невірні – взаємодія завершується. У іншому випадку користувач отримує можливість надати посилання на файл з фотографією штрих коду книги. Якщо штрих-код розпізнано, програмне забезпечення зчитує його та відправляє на сервер, в іншому випадку взаємодію буде завершено. Після того, як сервер проведе всі необхідні маніпуляції із отриманими даними, користувачу буде повернуто інформацію про додану книгу або помилку (якщо вона відбудеться на сервері), після чого взаємодія завершується.  

     Рисунок 5 – UML діаграма взаємодії
     
     Діаграма діяльності відіграє ключову роль у розгляді та створенні програмного забезпечення, дозволяючи візуалізувати послідовність подій в системі від початку до кінця конкретного процесу або функції. У даному проєкті вона використовується для ілюстрації процесу сканування штрих-коду книги, аналізу та обробки отриманих даних. Розроблену діаграму діяльності можна побачити на рисунку 6.
     Створена діаграма демонструє процес додавання нової книги користувачем за допомогою зчитування штрих-коду. Процес починається зі зчитування системою даних з наданого штрих-коду. Дані, що закодовано у штрих-коді представляють з себе ISBN номер книги, і у разі, якщо зчитування пройшло успішно, дані відправляються на сервер, де відбувається перевірка наявності книги з заданим ISBN номером і у разі, якщо такої книги немає у системі, відбувається запит до Google Books API для отримання розширених даних про задану книгу та збереження їх у базу даних. Після цього книга зберігається у масиві книг користувача і надається вся доступна про неї інформація.

     Рисунок 6 – UML діаграма діяльності
     Діаграма пакетів використовується для візуалізації структури пакетів (групування елементів моделі) та залежностей між ними в системі програмного забезпечення. Діаграму пакетів для програмного забезпечення для додавання книжок у систему наведено на рисунку 7.
     Система складається з головної програми та підключених до неї сервісів, а саме сервіс автентифікації, зчитування штрих-коду та додавання книги. Сервіс автентифікації використовується програмою задля надання користувачам можливості входу у систему, варто зазначити, що даний сервіс використовує розроблену Shelfy API (API програмної системи для організації та керування домашньою бібліотекою).  Головна система має доступ до сервісу зчитування штрих-коду задля того, щоб розпізнавати ISBN книжок з наданих користувачами фотографій. Даний сервіс використовує бібліотеку ZXing для розпізнавання штрих-кодів з фотографій. На останок, сервіс додавання книги на полицю головна програма використовує для відправки даних на сервер та отримання належної відповіді.  

     Рисунок 7 – UML діаграма пакетів
     

     3.3 Проектування клієнтської частини проєкту
     
     
     Діаграма прецедентів у мові UML служить для візуалізації того, як користувачі взаємодіють з системою, відображаючи різноманітні дії та їх зв'язки. UML-діаграму прецедентів зображено на рисунку 8,  вона ілюструє взаємодію користувачів з системою.
     Актор «Користувач» є головним актором системи, він розширює можливості актора «Гість», який, у свою чергу, має доступ лише до реєстрації або входу у систему. «Користувач» може переглядати свої останні книжкові доповнення, керувати книжковою полицею та додавати нові книги. Додавання відбувається за ручним введенням користувачем ISBN номеру книги. Для управління полицею «Користувач» має можливість пошуку книжок за назвою, автором та ISBN, фільтрації за датою додання книги на полицю, назвою, автором та рейтингом, відповідно. Інформацію про кожну збережену книгу «Користувач» може доповнювати такими даними як: рейтинг, статус та особисті нотатки, або видаляти, відповідно.  
     Також «Користувач» має доступ до особистого кабінету, де він має можливість редагувати конфіденційну інформацію, таку як пошта та пароль, та, за необхідності, «Користувач» має можливість вийти з системи. 
     Зокрема акторів «Користувач» та  «Гість» у системі також є актор «Адміністратор», він має доступ до розширеної системи адміністрування, яка дозволяє йому мати доступ до управління даними користувачів. «Адміністратор» має можливість видалення та призначення ролей користувачам системи.
     Також варто зазначити, що всі учасники системи мають можливість налаштування мови застосунку (українська або англійська).

     Рисунок 8 – UML діаграма прецедентів
     
     UML діаграма компонентів відображає структуру програмної системи на рівні компонентів та їх взаємозв’язків. Розроблену UML діаграма компонентів наведено на рисунку 9.
     У розробленій схемі кожен компонент відображає відповідний компонент(або сторінку) реалізованого клієнтського застосунку. Головна сторінка є центральним компонентом, адже вона відображає декілька останніх доданих на полицю книжок, надає користувачеві доступ до книжкової полиці, сторінки додання книг та особистого кабінету. Головний компонент, так як і компонент «Книжкова полиця», надає доступ до компоненту «Книга», що представляє з себе сторінки з детальною інформацією про відповідні книги. Також головний компонент надає доступ до компонентів «Вхід» та «Реєстрація», вони є пов’язаними із компонентом особистого кабінету, через який здійснюється вихід з системи та перехід до сторінок входу та авторизації.  

     Рисунок 9 – UML діаграма компонентів

     Діаграма пакетів [5] використовується для візуалізації структури пакетів (групування елементів моделі) та залежностей між ними в системі. Діаграму пакетів для клієнтської частини застосунку для організації та керування домашньої бібліотекою зображено на рисунку 10.
     У діаграмі пакетів зображено головний компонент, позначений як «App», адже для побудови клієнтського застосунку було використано бібліотеку React. Цей компонент є центральною частиною додатку та імпортує різні пакети, щоб забезпечити його функціональність. Зокрема, «App» імпортує пакети «Стилі», «Сторінки», «Компоненти», «Хуки» та «Контекст».
     Пакет «Сторінки» використовується для відображення різних сторінок або вікон у додатку. Він імпортує пакет «Стилі» для забезпечення зовнішнього вигляду сторінок та має доступ до пакету «Ресурси» для роботи з зображеннями, шрифтами та іншими допоміжними даними. Крім того, він використовує пакети «Хуки» та «Компоненти» для реалізації функціональності сторінок.
     Пакет «Компоненти» представляє будівельні блоки інтерфейсу, які використовуються на різних сторінках клієнтського застосунку. Він має доступ до пакету «Ресурси» і використовує пакет «Хуки»  для забезпечення взаємодії з даними та функціональністю.
     Пакет «Хуки» представляє набір допоміжний функцій, придатних для повторного використання. Він має доступ до пакету «Локалізації» для забезпечення локалізації тексту у застосунку і використовує пакет «Контекст» для обміну даними між різними компонентами.
     

     Рисунок 10 – UML діаграма пакетів
     


4 КОДУВАННЯ ПРОГРАМНОГО ПРОЄКТУ
4 
     4.1 Кодування серверної частини проєкту
     
     
     Під час розробки серверної частини проєкту були прийняті ряд інженерних рішень з метою забезпечення ефективності, надійності та масштабовності системи. Одним із головних аспектів було використання специфікації REST при розробці API. Це дозволило створити чіткий та стандартизований інтерфейс для взаємодії з сервером, що у майбутньому спростить розробку клієнтського додатку та забезпечить їх сумісність з будь-якою платформою. Специфікацію REST API наведено у таблиці 3.
     Під час розробки було використано Node.js та Express.js для створення серверної частини. Node.js надав можливість виконання JavaScript на серверній стороні, що у майбутньому надасть можливість писати код однією мовою як на клієнті. Express.js, у свою чергу, став основним фреймворком для побудови веб-застосунку на Node.js, забезпечуючи ряд корисних функцій та інструментів для розробки зручнго програмного інтерфейсу.
     Для побудови серверної частини була обрана архітектурна модель MVC (Model-View-Controller). Це дозволило розділити логіку додатку на три компоненти: модель (Model), представлення (View) та контролер (Controller). 
     Модель (Model) відповідає за доступ до даних та бізнес-логіку додатку. У розробленому сервері модель представлена базою даних MongoDB, яка зберігає інформацію про користувачів, книги та інші важливі дані. Модель також включає логіку для взаємодії з цими даними, забезпечуючи CRUD-операції (створення, читання, оновлення, видалення) та інші бізнес-процеси.
     Контролер (Controller) відповідає за обробку HTTP-запитів та керування потоком даних у додатку. Він взаємодіє з моделлю для отримання та збереження даних, а також забезпечує відповіді на запити, включаючи передачу даних клієнту. 
     Варто зазначити, що використана MVC архітектура є модифікованою, адже для створення користувацького інтерфейсу та відображення даних буде використано бібліотеку React, яка будується на компонентах. Компоненти є аналогом представлень (View) у традиційній архітектурі MVC, проте вони є більш гнучкими та зручними для перевикористання. React компоненти можуть взаємодіяти з сервером, відправляти запити та отримувати дані, а також відображати їх для користувача.
     Ця архітектура дозволила забезпечити відокремлення логіки та підвищити розширюваність та підтримку коду.
     Для авторизації користувачів у проєкті було використано JWT (JSON Web Token) токени. Філософія JWT полягає в створенні токенів, які можна перевіряти та підтверджувати без необхідності обміну даними з сервером кожен раз при кожному запиті.
     JWT токени складаються з трьох частин: заголовка (header), тіла (payload) та підпису (signature). У заголовку вказується тип токена та алгоритм шифрування. Тіло містить корисну інформацію, таку як ідентифікатор користувача та час необхідного оновлення токена. Підпис генерується за допомогою секретного ключа та даних з заголовка та тіла, що гарантує цілісність та автентичність токена. При авторизації користувача в системі йому надається токен, що підтверджує його особу та надає доступ до персональних даних про збережені на полиці книжки (див. дод. А). 
     У бізнес-логіці сервера проєкту основний акцент робиться на керуванні книгами та бібліотекою користувачів. Основні функції сервера включають додавання нових книг до бібліотеки (див. дод. А), можливість пошуку, відсортованого перегляду всіх збережених даних та, як результат, зручного впорядкування домашньої бібліотеки.
     Першочерговою задачею сервера є забезпечення можливості додавання нових книг до бібліотеки. Для цього сервер приймає ISBN книги, аналізує отримані дані, за необхідності звертаючись до Google Books Api задля отримання розширеної інформації про книги, за зберігає їх у відповідну колекцію. Додатково сервер забезпечує можливість пошуку книг за різними критеріями, такими як назва, автор та ISBN. Одним із важливих аспектів бізнес-логіки також є відображення всіх книг у бібліотеці користувача, яке може бути відсортоване за різними параметрами, такими як алфавітний порядок, дата додання книги до полиці,  тощо. Сервер також забезпечує можливість зручного впорядкування домашньої бібліотеки. Це включає функції, такі як надання книг статусу "Want to read", "Reading", "Finished", а також додавання рейтингу та нотаток до книг.
     Таблиця 3 – Специфікація REST API основного серверного додатку
СутністьМетодПосиланняОпис діїКористувачіGET/users/meПовернення поточного користувача/users/Повернення всіх користувачів системи/users/:idПовернення користувачаPOST/users/signupРеєстрація користувача у системи/users/loginВхід користувача у систему/users/forgotPasswordНадання тимчасового токена для оновлення пароляPATCH/users/resetPassword/:tokenОновлення забутого пароля/users/updatePasswordОновлення пароля/users/updateMeОновлення даних поточного користувача
     Кінець таблиці 3
/users/:idОновлення даних користувачаDELETE/user/:idВидалення користувачаКнигиGET/books/Повернення всіх книг/books/:idПовернення книгиPOST/books/Додання нової книгиПолицяGET/shelf/Повернення всіх книг з полиці/shelf/:idПовернення книг з полиціPOST/shelf/Додання книги на полицюPATCH/shelf/Оновлення інформації про збережену книгу/shelf/remove/:idВидалення книгу з полиці     
     
     4.2 Кодування IoT частини проєкту
     
     
     Для розробки системи додання нових книжок було обрано мову програмування С#. Цю мову було обрано з урахуванням її широких можливостей для розробки консольних програм та зручного доступу до багатьох сторонніх бібліотек.
     Для реалізації функціоналу зчитування штрих-кодів була використана бібліотека ZXing. Ця бібліотека забезпечує можливість розпізнавання штрих-кодів з фотографій або зображень. Її логіка роботи полягає у виявленні штрих-кодів на зображенні та ідентифікації відповідного коду, що у даному випадку представляє ISBN код книги. Код відповідного сервісу надано у додатку Б.
     Для взаємодії з сервером програма використовувала HTTP запити до розробленого API, яке було створено для проєкту "Shelfy". Це API надає доступ до різних функціональних можливостей системи, включаючи автентифікацію користувачів, управління їх бібліотекою та додавання нових книг. Використання HTTP запитів дозволило ефективно обмінюватися даними між клієнтом та сервером та забезпечити надійну комунікацію між компонентами системи (див. дод. Б). 
     Систему додання нових книжок на полицю було спроектовано з використанням сервісно-орієнтованої архітектури (SOA). Цей підхід означає, що функціонал системи розділений на окремі сервіси, які можуть працювати незалежно один від одного.
     Загалом, у системі є кілька ключових компонентів. Головна програма відповідає за основну логіку системи та взаємодію з користувачем. Ця програма взаємодіє з іншими сервісами, такими як сервіс автентифікації, сервіс зчитування штрих-кодів та сервіс додавання книг на полицю. Сервіс автентифікації використовується для перевірки ідентичності користувачів під час входу в систему. Сервіс зчитування штрих-кодів надає можливість сканування штрих-кодів книг та автоматичного їх додавання до бібліотеки користувача. Нарешті, сервіс додавання книг на полицю відповідає за приймання даних про книгу та їх збереження у базі даних. 
     Використання SOA дозволило зробити систему більш модульною, легко розширюваною та підтримуваною. Кожен сервіс може бути розгорнутий окремо, що полегшує розвиток та управління системою в цілому. Такий підхід забезпечує гнучкість та швидкість реакції на зміни в потребах користувачів та бізнес-вимогах.
     
     
     
     4.3 Кодування клієнтської частини проєкту
     
     
     Для розробки клієнтської частини програмної системи для організації та керування домашньою бібліотекою було використано бібліотеку React [4]. React – це бібліотека JavaScript для розробки інтерфейсу користувача. Оскільки проєкт побудований на основі React, архітектура може бути названа «React архітектурою» або «Компонентною архітектурою з використанням React». Основна логіка проєкту базується на концепції компонентів. Кожна частина інтерфейсу (сторінки, блоки, елементи) представлена окремим компонентом, який може мати власний стан та змінювати свій вигляд відповідно до змін стану. Це робить архітектуру гнучкою та легко розширюваною.
     Проєкт розділений на логічні модулі або компоненти, які відповідають за конкретну функціональність або частину інтерфейсу. Це дозволило зосередитися на конкретних частинах застосунку та легко керувати їх розробкою та підтримкою. Використання React хуків(допоміжних функцій) дозволило відокремити логіку компонентів від їх презентаційної частини, що зробило код більш чистим і зрозумілим. Також використовувався React контекст для обміну даними між різними компонентами без необхідності передачі даних через багато проміжних компонентів.
     Архітектура проєкту орієнтована на модульність і легкість розширення. Кожен компонент або модуль розроблений, тестований і підтримуваний незалежно від інших, що спростило процес розробки та забезпечило гнучкість системи.
     У розробці клієнтської частини для сторінок реєстрації та входу у систему основною метою було забезпечення безпеки та конфіденційності даних користувачів. У попередній лабораторній роботі при розробці серверної частини було використано JWT токени для автентифікації та авторизації користувачів. Щоб ефективно використати цей механізм підтвердження особи користувача, в клієнтській частині було використано контекст, адже він використовується для глобального зберігання та передачі даних по всьому додатку. Контекст було використано для відстеження статусу користувача (перевірка, чи автентифікований він) та захищення маршрутів, доступ до яких має бути обмежений (див. дод. В). Розроблену систему входу у систему зображено на рисунку 11.

     Рисунок 11 – сторінка входу у систему
     
     Головною сторінкою застосунку є "Книжкова Полиця", яка надає користувачеві можливість переглядати всі додані книги і виконувати пошук та сортування, її зображено на рисунку 12. Для отримання доступу до книжкової полиці на сервер відправляється відповідний запит, який містить JWT токен користувача в заголовку. Це зроблено для забезпечення безпечного доступу до даних та надання користувачеві саме його книжок. Відповідний хук(допоміжну функцію) для отримання масиву книжок наведено у додатку В.

     Рисунок 12 – сторінка «Книжкова Полиця»
     
     Також було розроблено сторінку з детальною інформацією про книгу. На цій сторінці користувач може передивлятись дані про додану книгу та лишати особисті примітки, такі як рейтинг, статус та нотатки (див. рис. 13).  Варто зазначити, що ця сторінка додатково надає можливість видалення книги з полиці.

     Рисунок 13 – Сторінка повної інформації про книгу
     У застосунку присутній заголовок, що лишається незмінним для всього додатку та надає користувачеві можливість пошуку книжок, доступу до особистого кабінету та кнопки зміни мови інтерфейсу. Його наведено на рисунку 14. Особистий кабінет, надає користувачу доступ до конфіденційної інформації та її редагування. Сторінка користувача наведена на рисунку 15.

Рисунок 14 – Заголовок застосунку

     Рисунок 15 – Особистий кабінет
     
     За допомогою навігаційного меню, наведеного на рисунку 16, користувач також має доступ до головної сторінки, та сторінки додавання нових книг. Головна сторінка відображається першою при вході користувача у систему, на ній надано ознайомчу інформацію та додатково зображено п’ять останніх доданих користувачем книжок (див. рис. 17).
     
     Рисунок 16 – Навігаційне меню

     Рисунок 17 – Головна сторінка
     
     Сторінка додавання нових книг має нескладний інтерфейс та забезпечує додавання нових книг у систему (див. рис. 18). Користувач має можливість надати ISBN бажаної книги та у разі, якщо дані надані вірно, додати книгу на полицю. 

     Рисунок 18 – Додання нової книги на полицю
     
     Додаток підтримує локалізацію, забезпечуючи користувацький інтерфейс англійською та українською мовами. Для цього було використано бібліотеку i18n, яка надає зручні інструменти для локалізації текстів у всьому додатку. Завдяки бібліотеці i18n текстові рядки було перекладено на різні мови та забезпечено можливість обрати бажану мову в у заголовку додатку(див. рис. 14). Наприклад, текстові елементи інтерфейсу, повідомлення про помилки, назви категорій або кнопок, автоматично змінюються відповідно до обраної користувачем мови (див. рис. 19). 
     Для впровадження однакової мови у всьому додатку було створено спеціальний контекст, який відповідає за керування локалізацією. Цей контекст забезпечує доступ до обраної мови у всіх частинах додатку і дозволяє змінювати мову безпосередньо з інтерфейсу (див. дод. В). 
     Крім того, обрана мова зберігається у локальному сховищі користувача, що дозволяє зберігати вибір мови між сеансами використання додатку. Це забезпечує зручність для користувачів, які можуть встановити свою улюблену мову один раз і не повторювати цей вибір при кожному вході.

     Рисунок 19 – Сторінка українською мовою
     
     Для програмної системи «Shelfy» було розроблено систему адміністрування (див. дод. В). Доступ до цієї системи має лише користувач з роллю «Адміністратор». Система дозволяє отримувати доступ до даних користувачів, видаляти їх профілі та редагувати ролі (див. рис. 20).  Варто зазначити, що система адміністрування, так само як і головний застосунок, підтримує англійську та українську мови користувацького інтерфейсу.

     Рисунок 20 – Панель адміністрування
     
     Відео демонстрацію тестування розробленого програмного забезпечення було викладено на платформу YouTube [6]. Створений програмний код окремих частин програмної системи було збережено у GitHub репозиторій [7].


ВИСНОВКИ
     
     
     Під час виконання курсового проєкту було проведено концептуальне моделювання та аналіз предметної області. На основі цього аналізу було розроблено комплексну програмну систему, яка забезпечує підвищення ефективності управління особистими книжковими колекціями користувачів.
     Розробка включила створення концептуальної моделі предметної області, що дозволило краще зрозуміти потреби користувачів і визначити основні вимоги до системи. Було здійснено проектування фізичної моделі даних та реалізацію системи з використанням сучасних технологій програмування.
     У результаті роботи було створено програмну систему, яка надає користувачам інструменти для ефективного управління своїми персональними бібліотеками, забезпечуючи зручність доступу до інформації, організацію та зберігання даних про книги. Для забезпечення надійності та зручності використання системи було проведено тестування, що включало перевірку коректності роботи всіх функцій та оцінку зручності інтерфейсу.
     Результатом даного курсового проєкту є розроблена система для організації та керування домашніми бібліотеками з однойменною назвою Shelfy, яка дозволяє користувачам легко додавати, сортувати та шукати книги, а також оцінювати їх та залишати примітки. Ця система є зручним інструментом для організації особистих книжкових колекцій, забезпечуючи простоту та ефективність управління.


ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ
     
     
     1. About Goodreads. URL: https://www.goodreads.com/about/us (дата звернення 01.04.24)
     2. Документація MongoDB Atlas. URL: https://www.mongodb.com/docs/atlas/getting-started/ (дата звернення 10.04.24)
     3. Документація Google Books API. URL: https://developers.google.com/books/docs/v1/using#WorkingBookshelves(дата звернення 15.04.24)
     4. Документація React. URL: https://react.dev/learn(дата звернення 03.05.24)
     5.  UML для бізнес-моделювання: для чого потрібні діаграми процесів. URL: https://evergreens.com.ua/ua/articles/uml-diagrams.html(дата звернення 05.04.24)
     6. Відео демонстрація тестування розробленого програмного забезпечення. URL: https://youtu.be/38gGaEzSqqk
     7. GitHub репозиторій. URL: https://github.com/NurePavlenkoPolina4/apzkr-pzpi-21-4-pavlenko-polina

     


ДОДАТОК А 
Код серверної частини


     Реєстрація користувача в системі 
1 const signToken = (id) =>
2   jwt.sign({ id: id }, process.env.JWT_SECRET, {
3     expiresIn: process.env.JWT_EXPIRES_IN,
4   });
5 
6 const createSendResponse = (user, statusCode, res) => {
7   const token = signToken(user._id);
8   const cookieOptions = {
9     expires: new Date(
10       Date.now() + process.env.JWT_COOKIE_EXPIRES_IN * 24 * 60 * 60 * 1000
11     ),
12     httpOnly: true,
13   };
14   if (process.env.NODE_ENV === "produnction") cookieOptions.secure = true;
15   res.cookie("jwt", token, cookieOptions);
16   user.password = undefined; //removing password from output
17   res.status(statusCode).json({
18     status: "success",
19     token,
20     data: {
21       user,
22     },
23   });
24 };
25 exports.signup = catchAsync(async (req, res, next) => {
26   const newUser = await User.create({
27     name: req.body.name,
28     email: req.body.email,
29     password: req.body.password,
30     passwordConfirm: req.body.passwordConfirm,
31   });
32   createSendResponse(newUser, 201, res);
33 });
34 
35 exports.login = catchAsync(async (req, res, next) => {
36   const { email, password } = req.body;
37   //1) Check if email and password exist
38   if (!email || !password) {
39     return next(new AppError("Please provide email and password!", 400));
40   }
41   //2) Check if user exists and password is correct
42   const user = await User.findOne({ email }).select("+password");
43   if (!user || !(await user.correctPassword(password, user.password))) {
44     return next(new AppError("Incorrect email or password!", 401));
45   }
46   //3) If everything is OK, send token to client
47   createSendResponse(user, 200, res);
48 });
     
     Додання нової книги на користувацьку полицю
1 const mergeBookData = async (req, bookIds) => {
2   const objectIdArray = bookIds.map((id) => new mongoose.Types.ObjectId(id));
3   let pipeline = [
4     { $match: { _id: new mongoose.Types.ObjectId(req.user.id) } },
5     { $unwind: "$books" },
6     {
7       $lookup: {
8         from: "books",
9         localField: "books.id",
10         foreignField: "_id",
11         as: "bookDetails",
12       },
13     },
14     { $unwind: "$bookDetails" },
15     { $match: { "books.id": { $in: objectIdArray } } },
16     {
17       $project: {
18         _id: "$bookDetails._id",
19         isbn: "$bookDetails.isbn",
20         title: "$bookDetails.title",
21         author: "$bookDetails.author",
22         year: "$bookDetails.year",
23         genres: "$bookDetails.genres",
24         description: "$bookDetails.description",
25         status: "$books.status",
26         rating: "$books.rating",
27         notes: "$books.notes",
28         addedAt: "$books.addedAt",
29       },
30     },
31   ];
32 
33   if (req.query.search) {
34     const search = req.query.search;
35     pipeline.push({
36       $match: {
37         $or: [
38           { isbn: { $regex: search, $options: "i" } },
39           { title: { $regex: search, $options: "i" } },
40           { author: { $regex: search, $options: "i" } },
41         ],
42       },
43     });
44   }
45   if (req.query.sort) {
46     const sortByArr = req.query.sort.split(",");
47     sortByArr.forEach((sortBy) => {
48       let order = 1; // default to ascending
49       if (sortBy[0] === "-") {
50         sortBy = sortBy.substring(1);
51         order = -1; // set to descending if '-' is present
52       }
53       pipeline.push({ $sort: { [sortBy]: order } });
54     });
55   }
56   if (req.query.page || req.query.limit) {
57     const page = req.query.page * 1 || 1;
58     const limit = req.query.limit * 1 || 100;
59     const skip = (page - 1) * limit;
60     pipeline.push({ $skip: skip }, { $limit: limit });
61   }
62 
63   // Execute aggregation pipeline
64   const bookshelf = await User.aggregate(pipeline);
65   return bookshelf;
66 };
67 
68 exports.addBookToShelf = catchAsync(async (req, res, next) => {
69   const { isbn } = req.body;
70   if (!validator.isISBN(isbn)) {
71     return next(new AppError("The ISBN number is not valid! Try again..."));
72   }
73   let book = await Book.findOne({ isbn });
74   if (!book) {
75     //Get request to the Open Library API to fetch book details
76     const apiUrl = `https://www.googleapis.com/books/v1/volumes?q=isbn:${isbn}`;
77     const googleapisRes = await axios.get(apiUrl);
78 
79     if (!googleapisRes.data.totalItems) {
80       return next(
81         new AppError("Sorry! We weren't able to find book with such ISBN...")
82       );
83     }
84     const {
85       title,
86       authors,
87       publishedDate,
88       categories: genres,
89       description,
90     } = googleapisRes.data.items[0].volumeInfo;
91     book = await Book.create({
92       isbn,
93       title,
94       author: authors ? authors.join(", ") : "Unknown",
95       year: publishedDate ? publishedDate.substring(0, 4) : null,
96       genres,
97       description,
98     });
99   }
100   let user = req.user;
101   if (
102     user.books.some(
103       (userBook) => userBook.id.toString() === book._id.toString()
104     )
105   ) {
106     return next(new AppError("This book is already in your shelf", 400));
107   }
108   user = await User.findByIdAndUpdate(
109     req.user.id,
110     { $addToSet: { books: { id: book._id } } },
111     { new: true, runValidators: true }
112   );
113   res.status(201).json({
114     status: "success",
115     data: {
116       book,
117     },
118   });
119 });
120

     


ДОДАТОК Б
Код IoT частини
     
     
     Сервіс для зчитування штрих-кодів 
1 using System;
2 using System.Drawing;
3 using ZXing;
4 using ZXing.Windows.Compatibility;
5 
6 namespace shelfy
7 {
8     public class BarcodeReaderService
9     {
10         public string ReadBarcode(string imagePath)
11         {
12             try
13             {
14                 // Check if the image path is provided
15                 if (string.IsNullOrEmpty(imagePath))
16                 {
17                     Console.WriteLine("ERROR: Image path cannot be empty.");
18                     return null;
19                 }
20 
21                 // Check if the image file exists
22                 if (!System.IO.File.Exists(imagePath))
23                 {
24                     Console.WriteLine("ERROR: Image file does not exist.");
25                     return null;
26                 }
27 
28                 // Create a barcode reader for Windows Compatibility
29                 var reader = new BarcodeReader();
30 
31                 // Load the image
32                 var barcodeBitmap = new Bitmap(imagePath);
33 
34                 // Convert bitmap to luminance source
35                 var luminanceSource = new BitmapLuminanceSource(barcodeBitmap);
36 
37                 // Detect and decode the barcode inside the luminance source
38                 var result = reader.Decode(luminanceSource);
39 
40                 // Check if a barcode was found
41                 if (result != null)
42                 {
43                     // Print the ISBN if barcode is found
44                     return result.Text;
45                 }
46                 else
47                 {
48                     Console.WriteLine("ERROR: No barcode found in the provided image.");
49                     return null;
50                 }
51             }
52             catch (Exception ex)
53             {
54                 Console.WriteLine($"ERROR: {ex.Message}");
55 
56                 return null;
57             }
58         }
59     }
60 }
61
     
     Сервіс для додання нової книги у систему 
1 using System;
2 using System.Net.Http;
3 using System.Text;
4 using System.Text.Json;
5 using System.Threading.Tasks;
6 
7 namespace shelfy
8 {
9     public class ShelfService
10     {
11         private readonly string _baseUrl = "http://127.0.0.1:3001/api/v1/shelf";
12 
13         public async Task<string?> AddBookToShelfAsync(string isbn, string jwtToken)
14         {
15             try
16             {
17                 // Create HTTP client
18                 using (var client = new HttpClient())
19                 {
20                     // Create request data
21                     var requestData = new
22                     {
23                         isbn = isbn
24                     };
25                     var jsonRequestData = JsonSerializer.Serialize(requestData);
26                     var requestContent = new StringContent(jsonRequestData, Encoding.UTF8, "application/json");
27 
28                     // Add JWT token as authorization header
29                     client.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", jwtToken);
30 
31                     // Send POST request to shelf endpoint
32                     var response = await client.PostAsync(_baseUrl, requestContent);
33 
34                     // Read response content
35                     var jsonResponse = await response.Content.ReadAsStringAsync();
36                     return jsonResponse;
37                     
38                 }
39             }
40             catch (HttpRequestException ex)
41             {
42                 Console.WriteLine($"ERROR: HTTP request failed: {ex.Message}");
43                 return null;
44             }
45             catch (Exception ex)
46             {
47                 Console.WriteLine($"ERROR: {ex.Message}");
48                 return null;
49             }
50         }
51     }
52 }
ДОДАТОК В
Код клієнтської частини
     
     
     React контекст автентифікації
1 import { createContext, useReducer, useEffect } from "react";
2 
3 export const AuthContext = createContext();
4 export const authReducer = (state, action) => {
5   switch (action.type) {
6     case "LOGIN":
7       return { user: action.payload };
8     case "LOGOUT":
9       return { user: null };
10     default:
11       return state;
12   }
13 };
14 export const AuthContextProvider = ({ children }) => {
15   const jwt = localStorage.getItem("jwt");
16   const initialUserState = jwt ? JSON.parse(jwt) : null;
17   const [state, dispatch] = useReducer(authReducer, {
18     user: initialUserState,
19   });
20 
21   useEffect(() => {
22     if (initialUserState) {
23       dispatch({ type: "LOGIN", payload: initialUserState });
24     }
25   }, [initialUserState]);
26 
27   return (
28     <AuthContext.Provider value={{ ...state, dispatch }}>
29       {children}
30     </AuthContext.Provider>
31   );
32 };
     
     React хук для отримання масиву книжок
1 import { useState, useEffect } from 'react';
2 import noCover from "./../assets/no-cover.jpg";
3 
4 
5 export function useBooks(fetchLink, user, setIsLoading) {
6   const [books, setBooks] = useState([]);
7 
8   useEffect(() => {
9     async function fetchData() {
10       setIsLoading(true)
11       try {
12         const response = await fetch(fetchLink, {
13           headers: {
14             Authorization: `Bearer ${user}`,
15           },
16         });
17         const data = await response.json();
18     
19         let booksData
20         if(data.data.books){
21           booksData = data.data.books;
22         }
23         else if(data.data.book){
24           booksData = data.data.book;
25         }
26         // Fetching book covers for each book
27         const booksWithCovers = await Promise.all(
28           booksData.map(async (book) => {
29             const cover = await fetchBookCover(book.isbn);
30             return { ...book, cover };
31           })
32         );
33         setBooks(booksWithCovers);
34         setIsLoading(false)
35       } catch (error) {
36         console.error("Error fetching data:", error);
37       }
38     }
39 
40     fetchData();
41   }, [fetchLink, setIsLoading, user]);
42 
43   async function fetchBookCover(isbn) {
44     try {
45       const response = await fetch(
46         `http://bookcover.longitood.com/bookcover/${isbn}`
47       );
48       const data = await response.json();
49       const cover = data.url;
50       return cover || noCover;
51     } catch (error) {
52       console.error("Error fetching book cover:", error);
53       return "";
54     }
55   }
56 
57   return { books };
58 }
     
     React контекст для впровадження локалізації
1 import React, { createContext, useState, useContext, useEffect } from "react";
2 import i18n from "./../i18n";
3 
4 const LanguageContext = createContext();
5 
6 export const LanguageProvider = ({ children }) => {
7   const [language, setLanguage] = useState(() => {
8     const storedLanguage = localStorage.getItem("language");
9     return storedLanguage || "en";
10   });
11   useEffect(() => {
12     i18n.changeLanguage(language);
13     localStorage.setItem("language", language);
14   }, [language]);
15   return (
16     <LanguageContext.Provider value={{ language, setLanguage }}>
17       {children}
18     </LanguageContext.Provider>
19   );
20 };
21 
22 i18n
23   .use(initReactI18next)
24   .init({
25     resources: {
26       en: {
27         translation: englishTranslations,
28       },
29       uk: {
30         translation: ukrainianTranslations,
31       },
32     },
33     fallbackLng: "en",
34     debug: true,
35     interpolation: {
36       escapeValue: false, 
37     },
38     react: {
39       useSuspense: false,
40     },
41   });
42 
43 export const useLanguage = () => useContext(LanguageContext);
     


ДОДАТОК Г
     Результат перевірки роботи на плагіат



0









